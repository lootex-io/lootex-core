import { CookieSerializeOptions } from 'cookie';
import {
  IsEmail,
  IsNotEmpty,
  IsUUID,
  IsEnum,
  IsOptional,
  IsNumber,
} from 'class-validator';
import { EMAIL_BLACKLIST, UUID_V4_REGEX } from '@/common/utils/constants';
import { EthAddress } from '@/external/blockchain';
import { Account } from '@/model/entities/account.entity';
import { Wallet } from '@/model/entities/wallet.entity';
import { modifyGmail } from '@/common/utils/modify-gmail';
import { Transform } from 'class-transformer';

export const ERC1271_MATCH_VALUE = '0x1626ba7e';

export const PRIVY_COOKIE_KEY = 'privy_token';

export type RequestWithCookie = Request & {
  cookies?: Record<string, string>;
};

export type RequestWithAuth = RequestWithCookie & {
  // @dev source of @CurrentUser
  user?: Account;
  // @dev source of @CurrentWallet
  wallet?: Wallet;
};

export type ResponseWithCookie = Response & {
  /**
   * @function cookie
   * @summary an alias for cookie#serialize to set cookie on current request context
   * @param {String} name key of this cookie
   * @param {String} value plain text value for the cookie to set
   * @param {CookieSerializeOptions} options set/serialisation options
   */
  cookie?(
    name: string,
    value: string,
    options?: CookieSerializeOptions,
  ): string;
};

export type AuthSupportedAddress = EthAddress;

export enum AuthEntityStatus {
  ACTIVE = 'ACTIVE',
  SUSPEND = 'SUSPEND',
}

export enum AuthSupportedChainFamily {
  ETH = 'ETH',
  SOL = 'SOL',
  FLOW = 'FLOW',
  APTOS = 'APTOS',
  SUI = 'SUI',
}

export enum AuthSupportedWalletTransport {
  INJECTED = 'Injected',
  CONTRACT = 'Contract',
  LIBRARY = 'Library',
}

// @dev should be shared with front-end
export enum AuthSupportedWalletProviderEnum {
  METAMASK_INJECTED = 'METAMASK_INJECTED',
  PHANTOM_INJECTED = 'PHANTOM_INJECTED',
  COINBASE_INJECTED = 'COINBASE_INJECTED',
  QUBIC_INJECTED = 'QUBIC_INJECTED',
  PETRA_INJECTED = 'PETRA_INJECTED',
  COMPATIBLE_INJECTED = 'COMPATIBLE_INJECTED',

  QUBIC_LIBRARY = 'QUBIC_LIBRARY',
  WALLET_CONNECT_1_LIBRARY = 'WALLET_CONNECT_1_LIBRARY',
  TORUS_LIBRARY = 'TORUS_LIBRARY',
  FLOW_LIBRARY = 'FLOW_LIBRARY',
  PRIVY_LIBRARY = 'PRIVY_LIBRARY',
  PRIVY_LIBRARY_SA = 'PRIVY_LIBRARY_SA',

  BLOCTO_WALLET_MOBILE = 'BLOCTO_WALLET_MOBILE',
  TRUST_WALLET_MOBILE = 'TRUST_WALLET_MOBILE',
}

export const AuthTorusSupportedVerifiers = {
  google: 'google',
  facebook: 'facebook',
  discord: 'discord',
  reddit: 'reddit',
  twitch: 'twitch',
};

export type AuthTorusVerifierTypes = 'discord' | 'google' | 'reddit';

export class AuthTorusPubAddrResponse {
  success: boolean;
  data: string;
}

export const AuthTorusFrontendVerifiers = {
  [AuthTorusSupportedVerifiers.google]: 'tkey-google',
  [AuthTorusSupportedVerifiers.facebook]: 'tkey-facebook',
  [AuthTorusSupportedVerifiers.discord]: 'discord',
  [AuthTorusSupportedVerifiers.reddit]: 'reddit',
  [AuthTorusSupportedVerifiers.twitch]: 'tkey-twitch',
};

export class LootexJwtPayload {
  // @dev standard claim, issuer identifier
  public readonly iss: string = 'Lootex';

  // @dev claim should be unique in the scope of the issuer
  //      in this case UserAccounts.id
  @IsNotEmpty()
  @IsUUID()
  public sub: string;

  // @dev standard claim, RFC-5322
  @IsNotEmpty()
  @Transform(modifyGmail)
  @IsEmail({
    host_blacklist: EMAIL_BLACKLIST,
  })
  public email: string;

  // @dev custom claim
  @IsNotEmpty()
  public username: string;

  public avatarUrl: string;

  // @dev custom claim
  @IsNotEmpty()
  @IsUUID()
  public wallet_id: string;

  // @dev standard claim, generated by JwtService
  @IsOptional()
  @IsNumber()
  public iat?: number;

  // @dev standard claim, generated by JwtService
  @IsOptional()
  @IsNumber()
  public exp?: number;

  constructor(
    accountId: string,
    email: string,
    username: string,
    avatarUrl: string,
    walletId: string,
  ) {
    if (
      typeof accountId !== 'string' ||
      typeof username !== 'string' ||
      typeof email !== 'string' ||
      typeof walletId !== 'string'
    ) {
      throw new TypeError('LootexJwtPayload: Illegal input type');
    }
    if (!UUID_V4_REGEX.test(accountId) || !UUID_V4_REGEX.test(walletId)) {
      throw new TypeError('LootexJwtPayload: Illegal UUID');
    }
    this.sub = accountId;
    this.email = email;
    this.username = username;
    this.avatarUrl = avatarUrl;
    this.wallet_id = walletId;
  }

  toObject(): Record<string, unknown> {
    return {
      iss: this.iss,
      sub: this.sub,
      username: this.username,
      email: this.email,
      avatarUrl: this.avatarUrl,
      wallet_id: this.wallet_id,
    };
  }
}

export class AuthGetChallengeResult {
  @IsNotEmpty()
  @IsEnum(AuthSupportedChainFamily)
  chainFamily: AuthSupportedChainFamily;

  @IsNotEmpty()
  address: string;

  @IsNotEmpty()
  challenge: string;
}

export class AuthSignUpResult {
  @IsNotEmpty()
  @IsUUID()
  id: string;

  @IsNotEmpty()
  @IsEmail()
  email: string;

  @IsNotEmpty()
  username: string;

  @IsNotEmpty()
  @IsEnum(AuthSupportedWalletTransport)
  transport: AuthSupportedWalletTransport;

  @IsNotEmpty()
  address: string;

  @IsNotEmpty()
  @IsEnum(AuthSupportedWalletProviderEnum)
  provider: AuthSupportedWalletProviderEnum;

  @IsUUID()
  walletId: string;

  @IsNotEmpty()
  referrer: Account;
}

export class AuthGetAccountInfoResult {
  @IsUUID()
  id: string;

  @IsEmail()
  email: string;

  @IsNotEmpty()
  username: string;

  @IsNotEmpty()
  fullname: string;

  @IsNotEmpty()
  avatarUrl: string;

  @IsNotEmpty()
  introduction: string;

  @IsUUID()
  walletId?: string;
}

export interface PrivyAuthTokenClaims {
  appId: string;
  expiration: number;
  issuedAt: number;
  issuer: string;
  sessionId: string;
  userId: string;
}

export interface SocialConnect {
  provider: SocialPlatform;
  providerAccountId: string;
  accessToken?: string;
  expires_at?: string;
  refreshToken?: string;
  name?: string;
  picture?: string;
  email?: string;
}

export enum SocialPlatform {
  FACEBOOK = 'facebook',
  TWITTER = 'twitter',
  DISCORD = 'discord',
}
